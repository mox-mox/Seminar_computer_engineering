
%{{{ Preamble

\documentclass[journal,a4paper]{IEEEtran}

%{{{ Packages

\usepackage[l2tabu,orthodox, abort]{nag}
\usepackage{fontspec}

\usepackage{microtype}
\frenchspacing

\usepackage{polyglossia}
\setdefaultlanguage{english}

\usepackage{graphicx}
\graphicspath{{../material/paper/}{../material/background/}}

\usepackage{minted}
\usepackage{lipsum}
%\usepackage[hyphens]{url}
\usepackage[obeyspaces, spaces]{url}
\usepackage{stfloats}
\fnbelowfloat




\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage[font=footnotesize]{subcaption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother

%}}}


%{{{ New commands

%\newcommand{\source}[1]{{\caption{\tiny {\fontspec{ProFontWindows} {Source: #1} } } } }
\newcommand{\source}[1]{Source: #1}
%}}}


%{{{ Avebritations

\def\krste/{Krste Asanovi\'c}
%\def\CC/{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\textbf{+}}\nolinebreak\hspace{-.03em}\raisebox{.4ex}{\tiny\textbf{+} } }
%}}}

%{{{ Some hacks

\hyphenation{op-tical net-works semi-conduc-tor}
\addto\captionsenglish{\renewcommand\tablename{Listing}} %Use the table environment for code listings
%}}}

%}}}



%{{{ inputfile

\input{../material/latex-add-ins/common}
% source: http://tex.stackexchange.com/questions/40738/how-to-properly-make-a-latex-project
\newcommand\inputfile[1]{%
    \InputIfFileExists{#1}{}{\typeout{No file #1.}}%
}


%\newcommand*{\COMPILEIMAGES}{}%


% Whether to compile the image-lets or include the pre-compiled ones
\newcommand*{\COMPILEIMAGES}{}%

\newcommand\inputimage[1]{%
	\ifdefined\COMPILEIMAGES
		\input{../material/latex-add-ins/image_sources/#1}
	\else
		\includegraphics[width=\textwidth,height=0.8\textheight,keepaspectratio]{../material/latex-add-ins/#1}
	\fi
}


%}}}



\makeatletter
\newcommand\footnoteref[1]{\protected@xdef\@thefnmark{\ref{#1}}\@footnotemark}
\makeatother

\widowpenalties 1 5

\newlength{\savedtextfloatsep}


%\addto\captionsenglish{\renewcommand{\refname}{Poingflip}}


% Adapted from https://tex.stackexchange.com/a/70946/69074
\makeatletter
\newcommand\Notefont{\normalsize}
\long\def\bibNote#1{\gdef\@bibNote{\item[]{\Notefont#1}}}
\renewenvironment{thebibliography}[1]{%
	\section*{\textsc{\refname}}%
	\normalfont\footnotesize\labelsep .5em\relax
	\renewcommand\theenumiv{\arabic{enumiv}}\let\p@enumiv\@empty
	\list{\@biblabel{\theenumiv}}{\@bibNote\settowidth\labelwidth{\@biblabel{#1}}%
	\leftmargin\labelwidth \advance\leftmargin\labelsep
	\usecounter{enumiv}}%
	\sloppy \clubpenalty\@M \widowpenalty\clubpenalty
	\sfcode`\.=\@m
}{%
	\def\@noitemerr{\@latex@warning{Empty `thebibliography' environment}}%
	\endlist
}
\makeatother

\bibNote{Links were last checked on \today.}




\newdimen\spaceleft
\spaceleft=\textheight
\multiply\spaceleft by -1




\begin{document}
%\setlength{\parindent}{0mm}

%{{{ Title, author, abstract and keywords

\title{RISC-V --- Architecture and Interfaces\\The RocketChip}


\author{Moritz~N\"oltner-Augustin\\%
University of Heidelberg, ZITI}
%	\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem M. N\"oltner is enrolled at the University of Heidelberg and is currently pursuing a B.S. degree in applied informatics.\protect\\
%	E-mail: sh386@ix.urz.uni-heidelberg.de}%
%\thanks{Manuscript received January 6, 2015; revised January 12, 2015.}}%

% The paper headers
\markboth{Advanced Seminar ``Computer Engineering'', UNIVERSITY OF HEIDELBERG WT16/17}%
{Shell \MakeLowercase{\textit{et al.}}: RISC-V --- Architecture and Interfaces\\The RocketChip}

\maketitle

\begin{abstract}
	This paper gives a short overview of the RocketChip system-on-chip generator and how to use it.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
	RISC-V, RocketChip, Boom, SoC generator.
\end{IEEEkeywords}

%}}}

%{{{
\section{Introduction}
\IEEEPARstart{C}{omputer} technology has seen the rise and fall of many instruction set architectures (ISAs) over time.
Proprietary ISAs not only lead to fragmentation of the CPU market as companies cannot easily use the already existing ISAs of their competitors, but are also vulnerable to extinction when their proprietor companies run into financial troubles.
Along with design complexity and licensing issues, these considerations led \krste/ et al.\ in 2010 to decide upon creating a new and free ISA for their next round of research projects at the University of California Berkeley (UCB).
This fifth reduced instruction set ISA developed at UCB, called RISC-V\cite{riscv}, is -- unlike its predecessors -- not only meant for teaching but also actual implementation.
With three supported word-widths (32, 64 and 128 bits\cite[Time: 17:06]{riscv-vid}), RISC-V is aimed at all possible computational environments ranging from small embedded systems up to full scale supercomputers.
To facilitate widespread adoption, the ISA is licensed permissively, allowing use for academic and commercial use in open- and closed-source designs free of charge and now, roughly 6 years after its inception, RISC-V is used in a number of roles:

%{{{ RISC-V adopters TODO: citations

\begin{itemize}
	\item The LowRISC project aims to become the ``linux of the hardware word''\cite{lowrisc}
	\item SiFive\cite{sifive} and OnChip are creating custom silicon products\cite{open-v}
	\item ETH Zurich and Universit√† di Bologna cooperate to create a state-of-the-art low-power parallel processor (PULP) and a single-core microcontroller derived from that processor (PULPino)\cite{pulp}
	\item India has decided that RISC-V is the new ``natinal ISA'' including defense systems\cite[Time: 46:55]{riscv-vid}), IIT-Madras is developing a range of processors for that\cite{iit-madras}
	%\item IIT-Madras is creating a processor\cite{iit-madras}
	\item NVIDIA will use the RISC-V ISA for the replacement of their Falcon processor\cite{nvidia}
	\item A number of vendors create commercial soft and hard implementations\cite{riscv-commercial} %TODO: Better text
	\item UCB uses RISC-V processors for research\cite{ucb-science} and teaching purposes\cite{sodor}
\end{itemize}
%}}}
%}}}

%{{{
\section{RocketChip}
%{{{ RocketChip overview

\begin{figure}[!t]
	\centering
	\includegraphics[width=3in]{rcov}
	\caption{Overview of the components of RocketChip.\newline\hspace{\linewidth}\source{Image taken from~\cite{rocket}}.}
	\label{rcov}
\end{figure}
%}}}
The UCB currently develops three lines of 64-bit\footnote{The RV64I instruction \texttt{ADDIW}\cite[p.28]{riscv} is present in the decoding tables\cite{code-tables}.}  RISC-V processors, Sodor\cite{sodor}, a collection of simple processors for teaching, Rocket\cite[p.4]{rocket}, a Scalar in-order processor, and Boom\cite{boom}, a superscalar out-of-order processor for high-performance applications.
All three are written in Chisel (Creating Hardware in a Scala Embedded Language), a hardware description language -- as the name implies -- embedded in Scala.
Chisel allows compilation into three distinct target formats: a cycle accurate \CC/ model for fast simulation and software development and verilog code aimed at implementation either in an FPGA or ASIC\@.
For Rocket and Boom there is a generator framework that can create a whole parametrised system around the processor cores, called RocketChip\cite{rocket}.
It will create one or more Rocket, Boom or custom cores, surround it with caches, optionally an FPU and accelerators to form one or more [compute-]tiles.
This assembly is then completed with an interconnect, caches and other components to form a complete CPU as shown in the schematic in figure~\ref{rcov}.


%{{{
\subsection{General Usage}
The RocketChip is maintained in a Git repository\cite{rc-github}.
To build the default-configuration RocketChip, one only has to clone the repository, build the included GCC toolchain for RISC-V, and run ``\texttt{make}'' as shown in listing~\ref{rcclone}. For building a Boom-chip, the steps are identical except that one also has to checkout the ``\texttt{boom}'' branch of the same repository which then includes the Booms' repo\cite{boom-github} as a submodule.

%{{{ RocketChip Build Steps (Listing I)

\begin{table}
	\caption{Build steps for RocketChip.\newline\hspace{\linewidth}Source: Collected from~\cite{rc-github} and~\cite{boom-github}.}
		\label{rcclone}
	\begin{subtable}[b]{0.9\linewidth}
		\begin{minted}[fontsize=\small, gobble=3, tabsize=2]{bash}
			# $RC is some place in the file system
			cd $RC
			git clone \
			https://github.com/ucb-bar/rocket-chip.git
			cd rocket-chip
			git checkout boom # Only to build Boom
			git submodule update --init --recursive
		\end{minted}
		\caption{Downloading and initialising.}
		%\label{rcclone}
	\end{subtable}
	\begin{subtable}[b]{0.9\linewidth}
		\begin{minted}[fontsize=\small, gobble=3, tabsize=2]{bash}
			cd $RC/riscv-tools
			export RISCV=/where/to/install/toolchain
			export PATH="${PATH}:$RISCV/bin"
			./build.sh # Takes about 45 min
		\end{minted}
		\caption{Building the RSCV-toolchain.}
		\label{rctoolchain}
	\end{subtable}
	\begin{subtable}[b]{0.9\linewidth}
		\begin{minted}[fontsize=\small, gobble=3, tabsize=2]{bash}
			# Substitute ExampleSmallConfig with
			# any available configuration.
			# Use e.g BOOMConfig when building a Boom
			cd $RC/emulator # Build the C++ simulator
			make run CONFIG=ExampleSmallConfig
			cd $RC/vsim     # Create the verilog code
			make -jN CONFIG=ExampleSmallConfig
		\end{minted}
		\caption{Building the SOC and a simulator.}
		\label{rcmake}
	\end{subtable}
\end{table}
%}}}

%If the environment variable \texttt{\$RISCV} is not set to point to a sane installation of the toolchain, the following build steps will fail, so the next part is building the RISC-V-toolchain as shown in listing~\ref{rctoolchain}.
If the environment variable \texttt{\$RISCV} is not set to point to a sane installation of the toolchain, the following build steps will fail, so building the RISC-V-toolchain as shown in listing~\ref{rctoolchain} is mandatory.

\subsection{Configurations}

\subsubsection{Building an existing Configuration}
The makefile has a variable named ``\texttt{CONFIG}'' which is set to the name of a configuration.
A configuration is a set of configuration options that define the generated system.
Available configuration options can be found in \texttt{\$(RC)/src/main/scala/coreplex/Configs.scala}, and include for example:
%{{{ RocketChip config options

\begin{itemize}
	\item Which core[s] (Rocket | BOOM | Custom)
	\item \#Tiles/Cores
	\item Which Cache configuration (Associativity, ECC, replacement policy)
	\item Which Debug hardware (\#Breakpoints, \#Performance Counters)
	\item Which floating point unit
	\item Which multiplication and division logic
	\item Implement atomic instructions
	\item Which Bootrom
	\item Which TileLink configuration
\end{itemize}
%}}}
These options are grouped into different build configurations which can be found in \texttt{\$RC/src/main/scala/rocketchip/Configs.scala}.
Building one of the pre-defined configurations is as simple as setting the \texttt{CONFIG} variable while \texttt{make}-ing the project.
Listing~\ref{rcmake} shows the steps to build the emulator and generate the verilog code for a certain RocketChip configuration.

The generated verilog code is placed into a single file of around 11MB (for \texttt{DefaultConfig}) and includes around 300 verilog modules.
However, the generated code does not only not use any generics like parameterised modules but also involves numerous verbatim copies of the same modules with only the name differing e.g. AsyncResetRegVec\_1..57 (also in \texttt{DefaultConfig}).
Furthermore, the verilog code uses distictive wires for every connection.
While this point-to-point connection scheme probably simplifies the generator code and allows to immediately know which output is driving a certain signal, it renders the code very hard to read as signals can go by many different names although they are electrically connected either directly or through instantiated submodules\footnote{e.g. the clock signal in \texttt{ExampleRocketTop} which is input to the module by the name \texttt{clock} and is electrically connected to \texttt{socBus\_clock}, \texttt{AXI4Fragmenter\_1\_clock}, \texttt{AXI4ToTL\_1\_clock}, \texttt{AsyncQueueSink\_1\_1\_clock}, \texttt{AsyncQueueSource\_1\_1\_clock}, \texttt{TLMonitor\_40..52\_clock}, \texttt{TLToAXI4\_2..3\_clock}, \texttt{TLWidthWidget\_2\_clock}, \texttt{bootrom\_TLAtomicAutomata\_clock}, \texttt{bootrom\_TLFragmenter\_clock}, \texttt{bootrom\_TLWidthWidget\_clock}, \texttt{bootrom\_clock}, \texttt{coreplex\_clock}, \texttt{extInterruptXing\_clock}, \texttt{intBus\_clock}, \texttt{l1tol2\_TLSourceShrinker\_clock}, \texttt{l1tol2\_TLWidthWidget\_clock}, \texttt{l2\_clock} and \texttt{peripheryBus\_clock}.}.



%{{{ Config Options (Listing II)

\begin{table}
	\caption{Overview of the configuration system.}
	\begin{subtable}[b]{0.9\linewidth}
		\begin{minted}[fontsize=\small, gobble=3, tabsize=2]{scala}
			class BaseCoreplexConfig
							extends Config ((site, here, up) => {
				case CacheBlockBytes => 64
				case CacheName("L1D") => CacheConfig(
				nSets= 64,
				nWays= 4,
				rowBits= site(L1toL2Config).beatBytes*8,
				nTLBEntries= 8,
				cacheIdBits= 0,
				splitMetadata = false)
				...
			})
			...
			class WithL1ICacheSets(sets: Int)
					extends Config((site, here, up) => {
				case CacheName("L1I") =>
					up(CacheName("L1I"), site).copy(nSets = sets)
			})

			class WithCacheBlockBytes(linesize: Int)
					extends Config((site, here, up) => {
				case CacheBlockBytes => linesize
			})
		\end{minted}
		\caption{Extract of some of the configuration options found in \texttt{\$RC/src/main/scala/coreplex/Configs.scala}.}
		\label{config-options}
	\end{subtable}
	\begin{subtable}[b]{0.9\linewidth}
		\begin{minted}[fontsize=\small, gobble=3, tabsize=2]{scala}
			// Config with 2-way, 32 sets x 64 bytes/block cache
			// tag: 21 bits, index: 5 bits, WS: 4 bits, BS: 2 bits
			class DualCoreConfig2way extends Config(
				new WithNCores(2) ++ new WithL1ICacheWays(2)
				                  ++ new WithL1ICacheSets(32)
				                  ++ new WithCacheBlockBytes(64)
				                  ++ new WithL2Cache
				                  ++ new BaseConfig)

			// Config with 4-way, 64 sets x 32 byts/block cache
			// tag: 21 bits, index: 6 bits, WS: 3 bits, BS: 2 bits
			class DualCoreConfig4way extends Config(
				new WithNCores(2) ++ new WithL1ICacheWays(4)
				                  ++ new WithL1ICacheSets(64)
				                  ++ new WithCacheBlockBytes(32)
				                  ++ new WithL2Cache
				                  ++ new BaseConfig)
		\end{minted}
		\caption{Example of new RocketChip configurations defined in \texttt{\$RC/src/main/scala/rocketchip/Configs.scala}.}
		\label{new-configs}
	\end{subtable}
\end{table}
%}}}
\subsubsection{Creating a new Configuration}
RocketChip configurations are written as Scala code and inherit from the \texttt{Config} class defined in \texttt{\$RC/src/main/scala/config/Configs.scala}, which sets up some functionality including the '++' operator that is used to add the configuration options, or one of its child classes which already have some options set.
To evaluate the propagation of different configuration options into the generated verilog code, two new configurations differing in cache associativity and size were created as shown in listing~\ref{new-configs} using the configurations options listed in listing~\ref{config-options}.
\subsubsection{Analysis of configuration propagation}
The instruction cache parameters were chosen for their simple observability. Unlike for example the TileLink configuration options, the cache parameters only affect one verilog module, \texttt{ICache\_icache}, and are relatively simple to check by examining the SRAM memories that are instantiated.
For the 2-way configuration, the core of the cache can be expected to be two 32x21 bit tag SRAMs and two 32x512 bit (32x64 bytes) data SRAMs\footnote{\label{note-width}Or, of course a configuration of smaller width but the same capacity}.
%Likewise one would expect four 64x21 bit tag SRAMs and four 64*256 bit (64*32 bytes) data SRAMs\footnotemark[\ref{note-width}] for the 4-way configuration.
Likewise one would expect four 64x21 bit tag SRAMs and four 64*256 bit (64*32 bytes) data SRAMs\footnoteref{note-width} for the 4-way configuration.

%{{{ Module ICache_icache (Listing III)

		\setlength{\savedtextfloatsep}{\textfloatsep}
		\addtolength{\textfloatsep}{-5mm}
\begin{table}
	\caption{Extracts from the generated ICache\_icache Module.}
	\label{srams}
	\begin{subtable}[b]{0.9\linewidth}
		%2-way:
		%tag                   index WS   BS
		%XXXXXXXXXXXXXXXXXXXXX XXXXX XXXX XX
		\begin{minted}[fontsize=\small, gobble=3, tabsize=2]{verilog}
			module ICache_icache(...);
				...
				module tag_array( // Instantiated once
					input  [4:0] RW0_addr,
					input   RW0_en,
					input   RW0_clk,
					input   RW0_wmode,
					input  [20:0] RW0_wdata_0,
					input  [20:0] RW0_wdata_1,
					output [20:0] RW0_rdata_0,
					output [20:0] RW0_rdata_1,
					input   RW0_wmask_0,
					input   RW0_wmask_1
				);
				reg [41:0] ram [31:0];
				...
				module _T_772( // Instantiated twice
					input  [7:0] RW0_addr,
					input   RW0_en,
					input   RW0_clk,
					input   RW0_wmode,
					input  [63:0] RW0_wdata,
					output [63:0] RW0_rdata
				);
				reg [63:0] ram [255:0];
				...
			endmodule
		\end{minted}
		\vspace*{1mm}
		\caption{The instantiated SRAMs for the 2-way configuration.}
		\label{srams-2-way}
	\end{subtable}
	\newline
	\vspace*{7mm}
	\newline
	\begin{subtable}[b]{0.9\linewidth}
		%4-way:
		%tag                   index  WS  BS
		%XXXXXXXXXXXXXXXXXXXXX XXXXXX XXX XX
		\begin{minted}[fontsize=\small, gobble=3, tabsize=2]{verilog}
			module ICache_icache(...);
				...
				module tag_array( // Instantiated once
					input  [5:0] RW0_addr,
					input   RW0_en,
					input   RW0_clk,
					input   RW0_wmode,
					input  [20:0] RW0_wdata_0,
					input  [20:0] RW0_wdata_1,
					input  [20:0] RW0_wdata_2,
					input  [20:0] RW0_wdata_3,
					output [20:0] RW0_rdata_0,
					output [20:0] RW0_rdata_1,
					output [20:0] RW0_rdata_2,
					output [20:0] RW0_rdata_3,
					input   RW0_wmask_0,
					input   RW0_wmask_1,
					input   RW0_wmask_2,
					input   RW0_wmask_3
				);
				reg [83:0] ram [63:0];
				...
				module _T_850( // Instantiated four times
					input  [7:0] RW0_addr,
					input   RW0_en,
					input   RW0_clk,
					input   RW0_wmode,
					input  [63:0] RW0_wdata,
					output [63:0] RW0_rdata
				);
				reg [63:0] ram [255:0];
				...
			endmodule
		\end{minted}
		\vspace*{1mm}
		\caption{The instantiated SRAMs for the 4-way configuration.}
		\label{srams-4-way}
	\end{subtable}
\end{table}
		%\setlength{\textfloatsep}{\savedtextfloatsep}
%}}}

Looking at the generated code shown in listing~\ref{srams}, it can be verified that SRAMS of the expected capacities are indeed created.
However, the two and four tag SRAMs are merged into a big single two- and four-port SRAM respectively.
The data SRAMs use a narrower but deeper storage array, providing word-wise access but retaining the correct capacity. The required capacity per cache is the same for both configurations so the same SRAM gets instantiated.
The used SRAM verilog modules get created by the script \texttt{\$RC/vsim/vlsi\_mem\_gen}, which per default, generates behavioural descriptions of the requested SRAMs.
For an actual implementation, this script should be adapted to generate verilog wrappers for actually available SRAM blocks.
Since such an implementation will be forced to always use the next bigger (wider and/or deeper) available SRAMs, it might be beneficial to dimension the cache accordingly to maximise the cache parameters within the used SRAMs.

Looking at the different iterations of generated code, some key modules like the tiles and caches do not seem to change much.
For the rest of the modules, instantiations change considerably when changing the parameters, so hand-writing code to interface to anything within the core except specified interfaces would seem rather unwise.
%}}}

%{{{
\subsection{Interfaces}
%\enlargethispage*{1\baselineskip}
%{{{ Figure 2: RocketChip Busses

		\setlength{\textfloatsep}{\savedtextfloatsep}
\begin{figure}%[!t]
	\centering
	\inputimage{image4}
	\caption{The principal busses in the RocketChip. The dashed parts are possible periphery modules and not part of RocketChip.}
	\label{busses}
\end{figure}
%}}}
While the internals of the generated RocketChip vary strongly depending on the configuration options, the external interface is more static.
Save the clock, the reset and the interrupt lines, it consists only of the debug interface and some high speed data busses.

Currently available open-sourced versions of RocketChip are tethered\cite{tether}, meaning they will need a host environment to start up.
In this process, the debug interface is essential, for loading a program to be run.
To support untetherd operation, some form of non-volatile program memory needs to be added and the bootloader has to be modified to load executable code from that memory.

%{{{
\subsubsection{TileLink}
The internal bus system uses TileLink\cite{tilelink}, which is specific to RocketChip and connects the tiles, caches and other core components.
%In standard configuration, the bus consists of two full-duplex, 64-bit data paths.
Using the TileLink and few ancilliary signals as the only interface for each tile allows easy exchanging of tiles, which is one of the key features allowing the BOOM project to use the RocketChip to create a full processor around their core.
See \cite[p.23 ff]{rcgen-tutorial} for an overview on how to implement a new tile.

The physical bus sytem used within the processor is divided into 4 blocks, each with independent synchronisation, data, address, source, size, mask, parameter and opcode signals, implementing two full-duplex paths.
The widths of these signals vary in different parts of the processor. For the Rocket tile in default configuration, there are two TileLink interfaces (io\_cached and io\_uncached) with a width of around 440 each.

TileLink is the cache coherence protocol on top of the physical bus system that connects different agents who participate in a coherent memory model. From TileLinks' point of view, each agent is either a
%\enlargethispage*{1\baselineskip}
%{{{ Description: TileLink Agents

\begin{description}[\IEEEsetlabelwidth{\texttt{Manager}}\IEEEusemathlabelsep]
	\item[\texttt{Client}] which manipulates data in cache blocks, or a
	\item[\texttt{Manager}] which tracks and controls the access and data flow of the cache blocks.
\end{description}
%}}}
An agent can also fit into both categories. For example, the L2 cache will appear as a client to caches farther out (or the memory), while managing its clients the L1 caches.
TileLink specifies 5 basic operations, called channels:
%{{{ Itemize: TileLink Channels
\begin{description}[\IEEEsetlabelwidth{\texttt{Release}}\IEEEusemathlabelsep]
		\label{tilelink-channels}
	\item[\texttt{Acquire}] For getting permissions on a cache block and writing back data
	\item[\texttt{Probe}] To find out if a client holds a certain cache block
	\item[\texttt{Release}] Response to a probe. Returns permissions for a cache block along with its changed data
	\item[\texttt{Grant}] Provide permissions and data for a cache block or acknowledge a release
	\item[\texttt{Finish}] Used as final acknowledgement after receiving a Grant to allow ordering transactions.
\end{description}
%}}}
A number of behavioural constraints have to be implemented in the agents to ensure consistent, deadlock-free operation:
%{{{ Itemize: TileLink constraints

\begin{itemize}
	%\item If the different channels share the same physical link, preemption rules must be followed to avoid a deadlock situation: Each channel listed in \ref{tilelink-channels} must have priority over the channels listed above it (So that \texttt{Finish} has highest priority and is always sent first.
	\item If the different channels share the same physical link, preemption rules must be followed to avoid a deadlock situation: Each channel listed above must have priority over the channels listed above it (So that \texttt{Finish} has highest priority and is always sent first.
	\item A \texttt{Manager} must wait for transactions on a block to be finished before accepting new requests on that block unless it can merge the results of the different transactions.
	\item A \texttt{Client} cannot release and respond to a \texttt{Probe} if there is still an outstanding voluntary \texttt{Release} on that block.
\end{itemize}
%}}}

%{{{ Figure 3: TileLink transactions

\begin{figure}%[!t]
	\centering
	\inputimage{image3}
	\caption{An example of TileLink request and release interactions.}
	\label{tile-transfer}
\end{figure}
%}}}
Figure~\ref{tile-transfer} gives an example of TileLink operations: Several \texttt{Clients} are managed by a higher-level \texttt{Manager} which is itself a client to the memory\footnote{There may be other managers -- with other clients -- that are siblings to the shown \texttt{Manager}, if the \texttt{Memory} is a Manager instead.}.
In the first shown transaction \texttt{Client0}, which may be a DMA engine or a processor core, requests a cache block. As a result, the \texttt{Manager} sends \texttt{Probe} messages to all \texttt{Clients} under its control.
At this point, there are two possibilities:
%\enlargethispage*{\baselineskip}
%{{{ Itemize: TileLink transaction possibilities

\begin{itemize}
	\item No \texttt{Client} holds the requested cache block.\\
		The \texttt{Clients} indicate this in their \texttt{Release} response and after receiving all negative responses, the \texttt{Manager} requests the block from \texttt{Memory}.
		When receiving the \texttt{Grant} with the cache data, it forwards it to \texttt{Client0}. On reception, \texttt{Client0} sends a \texttt{Finish} message\footnote{\label{no-finish-propagation}The \texttt{Manager} does not need to pass the \texttt{Finish} to a higher-level Manager if the used network guarantees ordering of the sent packages.}.
	\item One of the other \texttt{Clients} holds the requested cache block.\\
		It will release its hold of the cache block and return clobbered data with its \texttt{Release} message.
		The \texttt{Manager} now has the data and permissions for the cache block, so it can directly issue a \texttt{Grant} to \texttt{Client0} without contacting \texttt{Memory}. Like in the first case, \texttt{Client0} replies with a \texttt{Finish} message.\footnoteref{no-finish-propagation}
\end{itemize}
%}}}
If \texttt{Manager} implemented a directory, it would know if/which one of its \texttt{Clients} holds a requested cache block and therefore would not need to send the \texttt{Probes} to the other \texttt{Clients}, thereby saving bandwidth and minimising response time.

The second shown transaction is a voluntary release. \texttt{Client0} decides that it no longer needs to hold a cache block under its control and releases it by sending a \texttt{Release} message with the clobbered data to the \texttt{Manager}, which in turn sends a \texttt{Release} to the \texttt{Memory}.
The \texttt{Memory} acknowledges the voluntary release by issuing a \texttt{Grant} which the \texttt{Memory} passes to \texttt{Client0}.
For a simple write to memory, the diagram would look the same except that instead of \texttt{Release}, \texttt{Client0} would send an \texttt{Acquire} message with the data and parameters indicating that it does not need to acquire hold of the affected cache block.
%}}}

%{{{
\subsubsection{Advanced eXtensible Interface}
%\enlargethispage*{2mm}
%\enlargethispage*{1\baselineskip}
Earlier versions of RocketChip used a custom bus interface named Not A Standard Interface (NASTI and NASTI-Lite) for the external busses, but current versions use the Advanced eXtensible Interface (AXI) specified by ARM\cite{axi}.
AMBA and AXI are well known open standards not only with many peripherals readily available as IP\cite{axi-ip} but also good support for new development\cite{axi-tools}.

AXI uses a multi-channel interface where each channel is unidirectional.
It supports different topologies, including multilayered point-to-point connections, bus topologies and mixtures with multiple data-- but a shared address channel.
The protocol is transaction-oriented and all transfers are done as bursts (although it is possible to have bursts of only one beat).
Each channel has handshake signals (\texttt{Valid}, \texttt{Ready} and \texttt{Last} for the two data channels) and a two-bit response field and operates independent from the other channels.
Here, ``Independent'' means, that there are relatively few constraints on relative timing between the diffent channels.
While for example a read will (obviously) need to have the address to be read transmitted first, there is no such constraint for a write\footnote{However, if there is some sort of switch in the interconnect, this switch will have to buffer the data until it knows the target address so that it can transfer the data only to the intended device.}.
Each channel is equipped with four ID bits\footnote{For RocketChip. The specification only \textbf{suggests} using 4 bits for masters and 8 bits of ID for slaves.}, which allow matching transactions between the different channels.
Transactions from different masters or with different ID values may be reordered\footnote{While the specification states that transactions with different IDs or from different masters have no ordering restrictions, it imposes certain restrictions for sequences of transactions\cite[5.3]{axi} without defining what constitutes a sequence of transactions in contrast to some transactions a master sends over time.}.
Using independent unidirectional channels allows to insert register stages at arbitrary points in the physical interconnect, allowing tradeoffs between required baud rate, latency and routing complexity. E.g. for a component farther out a register stage may be added at the cost of an additional bus cycle of latency to avoid degrading the bus frequency.
AXI can use different power-of-two widths of the data paths up to 1024 bits, the default configuration of RocketChip uses 64 bits for both directions.
Signals pertaining to a channel are marked by a common prefix\footnote{In the port list of the RocketChip Verilog module, this is actually in the middle of the name, as the different AXI interfaces are also indicated with a prefix.}.
These prefixes are:
%\enlargethispage*{1\baselineskip}
%{{{ Description: AXI Channel Prefixes
%
\begin{description}[\IEEEsetlabelwidth{\texttt{\ldots\_aw\_\ldots}}\IEEEusemathlabelsep]
	\item[\texttt{\ldots\_aw\_\ldots}]   Write Address Channel
	\item[\texttt{\ldots\_w\_\ldots}]    Write Data Channel
	\item[\texttt{\ldots\_b\_\ldots}]    Write Response
	\item[\texttt{\ldots\_ar\_\ldots}]   Read Address Channel
	\item[\texttt{\ldots\_r\_\ldots}]    Read Data Channel
	\item[\texttt{\ldots\_c\_\ldots}]    (Low Power Interface)
\end{description}
%}}}
RocketChip does not use the Low Power Interface.
Although also being an intra-IC interconnect, AXI is narrower than TileLink, consisting of around 280 signals per interface with the RocketChip default configuration.

To support the need of real-world systems with multiple processing units for synchronisation, AXI has an exclusive access feature: A master can issue an exclusive read.
The addressed slave will provide the data like for a normal read.
If it supports exclusive access it sets the response to \texttt{EXOKAY} and store the address for watching.
When the master -- some time after receiving the \texttt{EXOKAY} response -- tries to exclusive write to the location with the same ID value, the slave will check if there was another write to the location.
In case there was no other write, the slave will store the new data and respond \texttt{EXOKAY}. In case there was a concurrent write the slave will respond \texttt{OKAY} and not change the stored data. The slave will only watch one address for each transaction ID. A successive exclusive read with the same transaction ID without the exclusive write first, will result in the slave updating the watch-address.
Detection of this capability is possible because a slave that does not support exclusive access will simply respond with \texttt{OKAY} (instead of \texttt{EXOKAY}).

Likewise, atomic access is supported as a concept.
Devices in an atomicity group are designed to support the same maximum size of atomic memory updates.
A write to one such device will update up to the bus width of bytes and address alignment atomically.
E.g. an 8-bit aligned write on a 64 bit bus will result in an atomic write, while a write that is only aligned to 4 bits will only have 4 bits updated atomically. There does not seem to be a defined way to query the atomicity size of a device.

AXI version 3 did support locked transactions where a master could request the interconnect to be locked. Since this was a seldomly required use case that not only added significant complexity to the interconnect but also degraded the quality of service guarantees, this capability was removed from AXI4. If an AXI3 device actually issues a locked transaction in an AXI4 environment, the transaction will be treated as a normal transaction by the AXI4 devices, meaning that software relying on this feature will need to be changed.

AXI supports some other, more advanced features like specifying the bufferability of a memory and peripheral devices that are only required to allow certain methods of access. Describing these would go beyond the scope of this paper.

For lower performance peripherals like simple IO ports or UARTs, there is AMBA AXI4-Lite\cite[B1]{axi} a simplified version of AXI4.
It supports neither bursts, nor transfers smaller than the bus size, nor exclusive access, the bus width is fixed to either 32 or 64-bits and -- as there is no ID field -- all accesses have to be in order.

Interfacing between AXI and AXI-Lite only requires some logic to create the correct transaction IDs on the AXI side if the AXI part of the system can be designed to use only transactions that conform to the AXI-Lite subset when communicating with the AXI-Lite subsystem.
For the other cases there is a Defined conversion mechanism\cite[B1.3]{axi} to allow interfacing.
%}}}
%}}}



%}}}

%\enlargethispage*{1\baselineskip}
%{{{
\section{Conclusion}
The RISC-V instruction set architecture is an interesting new player in the field of general purpose ISAs.
It has sparked interest by a broad spectrum of players spanning from research facilities over commercial chip vendors to state-owned defense projects with several implementations in the process of reaching or having reached market-ready status and intensive use in the research field.

Rocket and Boom are open-source implementations of RISC-V processor cores developed at the University of Berkeley, as is RocketChip, a framework written in Chisel that can create processors using Rocket-, Boom- or custom cores.

In this paper, RocketChip was examined, the steps for creating new configurations were laid out, the propagation of the configuration options in Chisel into the generated Verilog code was tested and the relevant internal and external bus interfaces were described.
%}}}

%\bigskip
%\enlargethispage*{2\baselineskip}
\flushbottom
%{{{
\begin{thebibliography}{}
	\bibitem{riscv}
		Specification for RISC-V:\\
		\url{https://riscv.org/specifications/}
	\bibitem{riscv-vid}
		Krste Asanoviƒá presenting RISC-V at Stanford University in 2014\\
		\url{https://youtu.be/vB0FC1DZqUM}
		\vspace*{0.9pt}
	\bibitem{lowrisc}
		The lowRISC project:\\
		\url{http://www.lowrisc.org/}
		\vspace*{0.9pt}
	\bibitem{sifive}
		The SiFive company, founded by the creators of RISC-V:\\
		\url{https://www.sifive.com/}
		\vspace*{0.9pt}
	\bibitem{open-v}
		Open-V, the Microcontroller developed by OnChip:\\
		\url{http://hackaday.com/2016/10/10/the-journey-toward-a -completely-open-microcontroller/}\\
		\url{https://www.crowdsupply.com/onchip/open-v}
		\vspace*{0.9pt}
	\bibitem{pulp}
		The Pulp processor project by ETH Zurich and UNIBO:\\
		\url{http://www.pulp-platform.org}\\
		\url{http://iis-projects.ee.ethz.ch/index.php/PULP}
		\vspace*{0.9pt}
	\bibitem{iit-madras}
		The Shakti processor project at IIT Madras:\\
		\url{http://rise.cse.iitm.ac.in/shakti.html}
		\vspace*{0.9pt}
	\bibitem{nvidia}
		Nvidias' anouncement to switch to RISC-V:\\
		\url{https://riscv.org/wp-content/uploads/2016/07/Tue1100_Nvidia_RISCV_Story_V2.pdf}
		\vspace*{0.9pt}
	\bibitem{riscv-commercial}
		List of companies presenting commercial implementations of \mbox{RISC-V} at Embedded World 2017\\
		\url{https://riscv.org/2017/03/risc-v-mainstream-ew2017/}
		\vspace*{0.9pt}
	\bibitem{ucb-science}
		Example of RISC-V used in research project at UC Berkeley:\\
		\url{https://www.youtube.com/watch?v=WJndUQssFBg&t=1539s}
		\vspace*{0.9pt}
	\bibitem{sodor}
		The Sodor processor collection:\\
		\url{https://github.com/ucb-bar/riscv-sodor}
		\vspace*{0.9pt}
	\bibitem{rocket}
		Asanoviƒá, Krste/Avizienis, Rimas/Bachrach, Jonathan et al.\\
		The Rocket Chip Generator. (2016)\\
		Technical Report No. UCB/EECS--2016--17, EECS Department, University of California, Berkeley.\\
		%\url{http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-17.html}
		\url{http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-17.pdf}
		\vspace*{0.9pt}
	\bibitem{boom}
		Celio, Christopher and Patterson, David A. and Asanoviƒá, Krste\\
		The Berkeley Out-of-Order Machine (BOOM): An Industry-Competitive, Synthesizable, Parameterized RISC-V Processor\\
		Technical Report No. Celio:EECS-2015-167, EECS Department, University of California, Berkeley.\\
		\url{http://www2.eecs.berkeley.edu/Pubs/TechRpts/2015/EECS-2015-167.pdf}
		\vspace*{0.9pt}
	\bibitem{code-tables}
		Decode tables for the three UCB developed RISC-v processors:\\
		\url{https://github.com/ucb-bar/riscv-sodor/blob/master/src/common/instructions.scala#L39}\\
		\url{https://github.com/ucb-bar/rocket-chip/blob/master/src/main/scala/rocket/IDecode.scala#L149}\\
		\url{https://github.com/ucb-bar/riscv-boom/blob/master/src/main/scala/decode.scala#L123}
		\vspace*{0.9pt}
	\bibitem{rc-github}
		The RocketChip github pages\\
		%\url{https://github.com/ucb-bar/rocket-chip}\\
		\url{https://github.com/ucb-bar/rocket-chip/tree/f1cb06142e28d837b6347fb09ea8de77e4d96d01}\\
		\url{https://github.com/ucb-bar/project-template}
		\vspace*{0.9pt}
	\bibitem{boom-github}
		The Berkeley Out Of Order Machine github page\\
		\url{https://github.com/ucb-bar/riscv-boom}
		\vspace*{0.9pt}
	\bibitem{tether}
		Github issue about untethered operation of RocketChip\\
		\url{https://github.com/ucb-bar/rocket-chip/issues/434}
		\vspace*{0.9pt}
	\bibitem{tilelink}
		The TileLink Specification, Version 0.3.3\\
		\url{https://docs.google.com/document/d/1Iczcjigc-LUi8QmDPwnAu1kH4Rrt6Kqi1_EUaCrfrk8}
		\vspace{0.9pt}
	\bibitem{rcgen-tutorial}
		Tutorial for the  Rocket Chip build system.\\
		\url{https://riscv.org/wp-content/uploads/2015/01/riscv-rocket-chip-tutorial-bootcamp-jan2015.pdf}
		\vspace*{0.9pt}
	\bibitem{axi}
		AMBA¬Æ AXI‚Ñ¢ and ACE‚Ñ¢ Protocol Specification, ARM 2011\\
		\url{https://www.arm.com/products/system-ip/amba-specifications}\\
		Specification, see (A1.1) (requires registration):\\
		\url{http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ihi0022b/index.html}\\
		Specification (download from third party without registration):\\
		\url{http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf}
		\vspace*{0.9pt}
	\bibitem{axi-ip}
		Exemplary listing of available IP cores:\\
		\url{https://www.design-reuse.com/sip/amba-axi-c-288/}
		\vspace*{0.9pt}
	\bibitem{axi-tools}
		AMBA AXI Accelerated Verification IP (VIP) by Cadence:\\
		\url{https://ip.cadence.com/ipportfolio/verification-ip/accelerated-vip/arm-amba-2/amba-axi-accelerated-vip}\\
		AXI Interconnect support by Xilinx:\\
		\url{https://www.xilinx.com/products/intellectual-property/axi_interconnect.html}\\
\advance\spaceleft by \pagetotal
\multiply\spaceleft by -1
%\typeout{Space on last page:}
%\showthe\spaceleft
\end{thebibliography}
%\enlargethispage{-5in}
%}}}


\end{document}
